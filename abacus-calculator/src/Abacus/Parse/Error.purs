module Abacus.Parse.Error
  ( ParseError(..)
  ) where

import Prelude
import Control.Alt ((<|>))
import Control.Plus (empty)
import Data.Array (fold, intercalate, (:))
import Data.Array as A
import Data.Maybe (Maybe(..), fromMaybe)

-- | The error datatype. BasicError is an autogenerated error with minimum
-- | description. CustomError contains a custom error message.
data ParseError
  = BasicError
    { expt :: Array String
    , unexpt :: Maybe String
    , pos :: Int
    }
  | CustomError
    { msgs :: Array String
    , pos :: Int
    }

derive instance parseErrorEq :: Eq ParseError

-- | Pretty prints an error. TODO: Consider creating a separate function for
-- | pretty printing.
instance parseErrorShow :: Show ParseError where
  show (BasicError { expt, unexpt, pos }) =
    fold
      [ showPos pos
      , "\n  Unexpected \""
      , fromMaybe "Nothing" unexpt
      , "\"."
      , "\n  Error parsing "
      , listWords "or" expt
      , "."
      ]
  show (CustomError { msgs, pos }) = intercalate "\n" (showPos pos : msgs)

showPos :: Int -> String
showPos pos = "  (Position " <> show pos <> ")"

listWords :: String -> Array String -> String
listWords sep ws = case A.init ws of
  Nothing -> ""
  Just [] -> last' ws
  Just i -> fold [ intercalate ", " i, " ", sep, " ", last' ws ]
  where
  last' xs = fromMaybe mempty $ A.last ws

-- | Merges two errors. Always prefer later positions and custom errors.
instance parseErrorSemigroup :: Semigroup ParseError where
  append = eAppend

eAppend :: ParseError -> ParseError -> ParseError
eAppend e1 e2 = case compare (ePos e1) (ePos e2) of
  LT -> e2
  EQ -> case e1, e2 of
    BasicError _, CustomError _ -> e2
    CustomError _, BasicError _ -> e1
    BasicError be1, BasicError be2 ->
      BasicError
        { expt: be1.expt <> be2.expt
        , unexpt: be1.unexpt <|> be2.unexpt
        , pos: be1.pos
        }
    CustomError ce1, CustomError ce2 ->
      CustomError
        { msgs: ce1.msgs <> ce2.msgs, pos: ce1.pos }
  GT -> e1

-- | Note: This is technically only a valid monoid instance if `pos` is
-- | unsigned.
instance parseErrorMonoid :: Monoid ParseError where
  mempty =
    BasicError
      { expt: []
      , unexpt: empty
      , pos: 0
      }

-- | Gets position of error.
ePos :: ParseError -> Int
ePos (BasicError { pos }) = pos

ePos (CustomError { pos }) = pos
